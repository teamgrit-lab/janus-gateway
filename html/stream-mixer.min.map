{"version":3,"sources":["webpack://StreamMixer/webpack/universalModuleDefinition","webpack://StreamMixer/webpack/bootstrap","webpack://StreamMixer/./src/index.js","webpack://StreamMixer/./src/StreamMixer.Debugger.js","webpack://StreamMixer/./src/AudioMixer/AudioObject.js","webpack://StreamMixer/./src/AudioMixer/AudioMixer.js","webpack://StreamMixer/./src/VideoMixer/preset/POSITIONS.js","webpack://StreamMixer/./src/VideoMixer/VideoMixer.js","webpack://StreamMixer/./src/VideoMixer/VideoObject.js","webpack://StreamMixer/./src/StreamMixer.js","webpack://StreamMixer/./src/Module.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","console","log","default","StreamMixer_Debugger","_startTime","_videoState","videoMixer","videoElementList","droppedFrames","cTime","performance","now","cDebug","label","params","init","showObjectList","Frames","_lastExecuteTime","_lastFrameDelay","setLastExecuteTime","time","setLastFrameDelay","lastDrawTime","lastDrawTimeVideoObjects","showObjectDrawTimes","DroppedFrames","increase","show","div","AudioObject","[object Object]","id","source","sourceType","context","destination","mediaType","muted","_id","_source","_sourceType","_audioCtx","_destination","_mediaType","_muted","_sourceNode","createMediaStreamSource","createMediaElementSource","_gainNode","createGain","gain","filter","createBiquadFilter","geometricMean","Math","sqrt","frequency","Q","connect","disconnect","setValueAtTime","currentTime","AudioMixer","AudioContext","window","webkitAudioContext","audioCtx","createMediaStreamDestination","_isEnable","audioObjectList","addNoiseOscillator","oscillator","createOscillator","type","start","masterNode","aObj","push","idx","findIndex","val","splice","stream","getTracks","mute","setVolume","SCREEN","width","height","MARGIN","TOP","LEFT","RIGHT","BOTTOM","SIZE","SMALL","WIDTH","HEIGHT","PRESET_POSITION","FULL","top","left","LEFT_FULL","RIGHT_FULL","TOP_LEFT_SMALL","TOP_RIGHT_SMALL","getHorizontalRight","TOP_CENTER_SMALL","getHorizontalCenter","BOTTOM_LEFT_SMALL","getVerticalBottom","BOTTOM_RIGHT_SMALL","BOTTOM_CENTER_SMALL","objWidth","objHeight","FRAME_MIN_TIME","INTERVAL","MAX_FRAME_TIME","MIN_FRAME_TIME","lastFrameTime","VideoMixer_SIZE","MIN_WIDTH","MIN_HEIGHT","GUIDE","POINT_SIZE","LINE_WIDTH","LINE_COLOR","Z_INDEX_BUTTON_WIDTH","Z_INDEX_BUTTON_HEIGHT","Z_INDEX_BUTTON_COLOR","Z_INDEX_BUTTON_COLOR_UP","Z_INDEX_BUTTON_COLOR_DOWN","Z_INDEX_TEXT_FONT","Z_INDEX_TEXT_FONT_SIZE","Z_INDEX_TEXT_WIDTH","Z_INDEX_TEXT_HEIGHT","ARROW_WIDTH","ARROW_HEIGHT","ARROW_COLOR","MOUSE_BUTTON","NONE","CLICKED","SETTINGS","Z_INDEX_MIN","Z_INDEX_MAX","VideoMixer_VideoMixer","canvasElementID","previewVideoElementID","videoObjectList","videoObjectListAsc","mouseButtonState","initCanvas","vRatio","uiCanvas","offsetWidth","hRatio","offsetHeight","delta","then","Date","bindEventHandler","document","querySelector","uiCanvasCtx","getContext","desynchronized","alpha","frontCanvas","createElement","frontCanvasCtx","mixedStream","captureStream","setEnable","vObj","sortVideoObjectList","ascIdx","detachEventObject","requestAnimationFrame","draw","bufferCanvasCtx","clearRect","fillStyle","fillRect","map","drawSource","getDrawSource","src","drawImage","bufferCanvas","mouseOverObject","isFullscreen","drawOutline","drawTriangle","drawZIndexButton","drawCalcDeltaTime","forEach","videoWidth","videoHeight","getVideoTracks","requestFrame","startTime","executeTime","nextFrameDelay","setTimeout","drawWithFps","drawWithoutFps","destObject","ctx","strokeStyle","lineWidth","strokeRect","parseInt","beginPath","x","y","moveTo","lineTo","closePath","fill","drawTopLeft","drawBottomRight","objTop","objRight","drawUpButton","color","drawDownButton","clickPosition","drawButtonBackground","drawUpArrow","drawDownArrow","captureFrame","canvas","sort","a","b","zIndex","createdAt","length","ondblclick","e","clickObj","findClickObject","hasSavedPosition","restorePosition","savePosition","ratio","setPosition","fullScreen","aspectRatio","calcWidth","calcHeight","onmousedown","button","clickObject","startPos","offsetX","offsetY","startObjectPos","bottom","right","onmouseover","onmouseout","onmousemove","detectMouseOut","style","cursor","moveX","moveY","moveX_inCanvas","calcUItoCanvasX","moveY_inCanvas","calcUItoCanvasY","resizeWidth","resizeHeight","onmouseup","onclick","objList","mouseX","mouseY","find","objLeft","objBottom","videoObj","lastDrawExecuteTime","toString","VideoObject_VideoObject","props","autoSize","transparent","onended","enabled","_transparent","_enabled","_top","_left","_bottom","_right","_width","_height","_zIndex","_fullScreen","_createdAt","wScale","max","_savedPosition","_oldTop","_oldLeft","_oldBottom","_oldRight","_oldWidth","_oldHeight","_oldZIndex","_oldFullScreen","oldRight","values","undefined","outLine","onOff","_outline","_drawExecuteTime","StreamMixer","_videoElementList","_videoMixer","_audioMixer","_previewVideoID","_outputStream","findVideoItem","objID","k","generateID","random","substr","initStream","async","MediaStream","track","addTrack","getAudioTracks","videoElementID","addMedia","video","audio","Promise","resolve","reject","videoEl","autoplay","load","crossOrigin","srcObject","play","addVideoObject","getDestination","addAudioObject","catch","err","removeMedia","removeVideoObject","removeAudioObject","changeStream","item","getStream","enableCanvas","pause","getCurrentTime","setCurrentTime","getVideoObject","setDrawMode","Debug","__webpack_exports__"],"mappings":"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","file":"stream-mixer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StreamMixer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StreamMixer\"] = factory();\n\telse\n\t\troot[\"StreamMixer\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","console.log(\"%cStreamMixer 1.7.47dev5\", 'font-weight: 700;')\nconsole.log(\"Resolution : 320 x 180\");\nconsole.log(\"FrameRate : 15\");\nmodule.exports = require('./Module').default;","export default (function() {\n    let _startTime = null;\n    let _videoState = {\n        videoMixer: null,\n        videoElementList: 0,\n        droppedFrames: 0,\n    }\n\n    function cTime() {\n        console.log((`%c[START TIME]%c : ${_startTime}`),\n            // 'font-weight: 700;',\n            'font-weight: 700; color: white; background: orange;',\n            'font-weight: 400; background: none');\n        console.log((`%c[CURRENT TIME]%c : ${performance.now()}`),\n            // 'font-weight: 700;',\n            'font-weight: 700; color: white; background: orange;',\n            'font-weight: 400; background: none');\n    }\n\n    function cDebug(label, params) {\n        console.log(`%c[DEBUG]%c(${label}) : ${params}`,\n                    // 'font-weight: 700;',\n                    'font-weight: 700; color: white; background: green;',\n                    'font-weight: 400; background: none');\n    }\n\n    function init(videoElementList, videoMixer) {\n        _startTime = performance.now();\n        _videoState.videoMixer = videoMixer;\n        _videoState.videoElementList = videoElementList\n    }\n\n    function showObjectList() {\n        cDebug(\"ObjectList\", _videoState.videoElementList)\n    }\n\n    let Frames = (function(){\n        let _lastExecuteTime = 0;\n        let _lastFrameDelay = 0;\n        function setLastExecuteTime(time) {\n            _lastExecuteTime = time;\n        }\n        function setLastFrameDelay(time){\n            _lastFrameDelay = time;\n        }\n        function lastDrawTime() {\n            cTime();\n            cDebug(\"LastExecuteTime\", _lastExecuteTime);\n            cDebug(\"LastFrameDelay\", _lastFrameDelay);\n            cDebug(\"Total\", _lastExecuteTime + _lastFrameDelay);\n        }\n\n        function lastDrawTimeVideoObjects() {\n            cTime();\n            cDebug(\"ObjectsLastExecuteTime\", _videoState.videoMixer.showObjectDrawTimes() )\n        }\n\n        return { setLastExecuteTime, setLastFrameDelay, lastDrawTime, lastDrawTimeVideoObjects }\n    })()\n\n    let DroppedFrames = (function() {\n        function increase() {\n            _videoState.droppedFrames = _videoState.droppedFrames + 1;\n        }\n        function show() {\n            cTime();\n            cDebug(\"DroppedFrames\", _videoState.droppedFrames);\n            const div = (performance.now() - _startTime) / 1000\n            cDebug(\"DroppedFrames/s\", _videoState.droppedFrames / div);\n        }\n\n        return { increase, show }\n    })()\n\n    return {\n        init,\n        showObjectList,\n        Frames,\n        DroppedFrames\n    }\n})()","export const convertAudioStream = src => {\n    const stream = new MediaStream();\n    \n    if (src instanceof MediaStream) {\n        src.getAudioTracks().forEach(track => stream.addTrack(track));\n    }\n    else if (src instanceof MediaStreamTrack) {\n        stream.addTrack(src);\n    }\n    // else throw new Error();\n\n    return stream;\n};\n\nexport default class AudioObject {\n    constructor({\n        id,\n        source = null,\n        sourceType = \"stream\",\n        context,\n        destination,\n        mediaType,\n        muted,\n    }) {\n        this._id = id;\n        this._source = source;\n        this._sourceType = sourceType;\n        // this._source = convertAudioStream(source);\n        this._audioCtx = context;\n        this._destination = destination;\n\n        this._mediaType = mediaType;\n        this._muted = muted;\n\n        // this._filteredNode = this._audioCtx.createGain();\n        // this._filteredNode.gain.value = 1.0;\n        if(this._sourceType === \"stream\") {\n            this._sourceNode = this._audioCtx.createMediaStreamSource(this._source);\n        } else {\n            this._sourceNode = this._audioCtx.createMediaElementSource(this._source);\n        }\n\n        this._gainNode = this._audioCtx.createGain();\n\n        if (mediaType === \"mycam\") {\n            this._gainNode.gain.value = 0.5;\n            // voice bandpass filter\n            const filter = this._audioCtx.createBiquadFilter()\n            var geometricMean = Math.sqrt(300 * 3400);\n            filter.frequency.value = geometricMean;\n            filter.Q.value = geometricMean / (300 - 3400);\n\n            // if mic node is source then -> filter -> gain -> dest\n            this._sourceNode.connect(filter);\n            filter.connect(this._gainNode);\n        } else {\n            this._gainNode.gain.value = 1.0;\n            // if mic node is not source then -> gain -> dest\n            this._sourceNode.connect(this._gainNode);\n        }\n\n        this._gainNode.connect(this._destination);\n\n\n        // this._audio.play();\n        // console.log(this._destination)\n\n        // this._gainNode = this._audioCtx.createGain();\n        // this._gainNode.gain.value = 1.0;\n\n        // this._sourceNode.connect(this._gainNode);\n// console.log(\"audio type\", type)\n//         if (type === \"mic\") {\n//             const lowpassFilterNode = this._audioCtx.createBiquadFilter();\n//             lowpassFilterNode.type = 'lowpass';\n//             lowpassFilterNode.frequency.setValueAtTime(100, this._audioCtx.currentTime);\n\n//             const highpassFilterNode = this._audioCtx.createBiquadFilter();\n//             highpassFilterNode.type = 'highpass';\n//             highpassFilterNode.frequency.setValueAtTime(1500, this._audioCtx.currentTime);\n\n//             this._gainNode.connect(lowpassFilterNode);\n//             lowpassFilterNode.connect(highpassFilterNode);\n//             highpassFilterNode.connect(this._filteredNode);\n//         } else {\n//             this._gainNode.connect(this._filteredNode)\n//         }\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    disconnect() {\n        this._gainNode.disconnect();\n        this._sourceNode.disconnect();\n    }\n\n    mute(value) {\n        if(value) {\n            this._gainNode.gain.setValueAtTime(0, this._audioCtx.currentTime);\n        } else {\n            // this._sourceNode.connect(this._gainNode);\n            // this._gainNode.connect(this._destination);\n\n            // if (this._mediaType === \"mic\") {\n            //     this._gainNode.gain.setValueAtTime(0.5, this._audioCtx.currentTime);\n            // } else {\n            //     this._gainNode.gain.setValueAtTime(1.0, this._audioCtx.currentTime);\n            // }\n            this._gainNode.gain.setValueAtTime(1.0, this._audioCtx.currentTime);\n        }\n    }\n\n    setVolume(value) {\n        this._gainNode.gain.setValueAtTime(value, this._audioCtx.currentTime);\n    }\n\n}","import AudioObject, { convertAudioStream } from \"./AudioObject\";\n\n\nconst setVolume = ({ node, volume }) => {\n    const _volume = parseInt(volume, 10) / 100;\n    if (_volume < 0 || _volume > 1) throw new Error('volume scope exceed');\n    if (!node) throw new Error('node is null');\n\n    // eslint-disable-next-line no-param-reassign\n    node.gain.value = _volume;\n};\n\nconst getVolume = node => {\n    return node.gain.value;\n};\n\nexport default class AudioMixer {\n    constructor() {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        \n        this.audioCtx = new AudioContext();\n        this.destination = this.audioCtx.createMediaStreamDestination();\n        this._isEnable = true;\n        this.audioObjectList = [];\n\n        this.addNoiseOscillator();\n    }\n\n    addNoiseOscillator() {\n        const oscillator = this.audioCtx.createOscillator();\n        oscillator.type = 'sine';\n        oscillator.frequency.setValueAtTime(24000, this.audioCtx.currentTime); // value in hertz\n        oscillator.connect(this.destination);\n        oscillator.start();\n    }\n\n    getContext() {\n        return this.audioCtx;\n    }\n\n    getDestination() {\n        return this.destination;\n    }\n\n    getMasterNode() {\n        return this.masterNode;\n    }\n    \n\n    addAudioObject(aObj) {\n        this.audioObjectList.push(\n            aObj\n        )\n    }\n\n    removeAudioObject(id) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        if(idx === -1) return;\n        const aObj = this.audioObjectList[idx];\n        aObj.disconnect();\n        this.audioObjectList.splice(idx, 1)\n    }\n\n    getAudioTracks() {\n        return this.destination.stream.getTracks();\n    }\n \n    mute(id, value) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        const aObj = this.audioObjectList[idx];\n        aObj.mute(value);\n    }\n\n    setVolume(id, value) {\n        const idx = this.audioObjectList.findIndex(val => val.id === id);\n        const aObj = this.audioObjectList[idx];\n        aObj.setVolume(value)\n    }\n}\n","export const SCREEN = {\n    // width: 1280,\n    // height: 720,\n    width: 640,\n    height: 360,\n    // width: 320,\n    // height: 180\n}\n\nconst MARGIN = {\n    TOP: 10,\n    LEFT: 10,\n    RIGHT: 10,\n    BOTTOM: 10\n}\n\nexport const SIZE = {\n    SMALL: {\n        WIDTH: SCREEN.width / 4,\n        HEIGHT: SCREEN.height / 4\n    }\n}\n\nexport const PRESET_POSITION = {\n    FULL: {\n        top: 0,\n        left: 0,\n        width: SCREEN.width,\n        height: SCREEN.height\n    },\n    LEFT_FULL: {\n        top: 0,\n        left: 0,\n        width: SCREEN.width / 2,\n        height: SCREEN.height\n    },\n    RIGHT_FULL: {\n        top: 0,\n        left: SCREEN.width / 2,\n        width: SCREEN.width / 2,\n        height: SCREEN.height\n    },\n    TOP_LEFT_SMALL: {\n        top: MARGIN.TOP,\n        left: MARGIN.LEFT,\n        ...SIZE.SMALL\n    },\n    TOP_RIGHT_SMALL: {\n        top: MARGIN.TOP,\n        left: getHorizontalRight(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    TOP_CENTER_SMALL: {\n        top: MARGIN.TOP,\n        left: getHorizontalCenter(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    BOTTOM_LEFT_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: MARGIN.LEFT,\n        ...SIZE.SMALL\n    },\n    BOTTOM_RIGHT_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: getHorizontalRight(SIZE.SMALL.WIDTH),\n        ...SIZE.SMALL\n    },\n    BOTTOM_CENTER_SMALL: {\n        top: getVerticalBottom(SIZE.SMALL.HEIGHT),\n        left: getHorizontalCenter(SIZE.SMALL.HEIGHT),\n        ...SIZE.SMALL\n    }\n}\n\nfunction getHorizontalRight(objWidth) {\n    return SCREEN.width - objWidth - MARGIN.RIGHT;\n}\n\nfunction getHorizontalCenter(objWidth) {\n    return (SCREEN.width / 2) - (objWidth / 2);\n}\n\nfunction getVerticalBottom(objHeight) {\n    return SCREEN.height - objHeight - MARGIN.BOTTOM;\n}\n\nfunction getVerticalCenter(objHeight) {\n    return (SCREEN.height / 2) - (objHeight / 2);\n}","import Debugger from '../StreamMixer.Debugger';\n// import VideoObject from './VideoObject';\n\n// import { WORKER_MESSAGE_TYPE } from './workers/VideoMixerWorker';\n\nimport { SCREEN } from './preset/POSITIONS';\n\nexport const EXT_WORKER_MESSAGE_TYPE = {\n    PUT_OFFSCREEN: \"PUT_OFFSCREEN\"\n}\n\nconst FRAMES_PER_SECOND = 15;\n// requesetAnimFrame용\nconst FRAME_MIN_TIME = (1000 / 60) * (60 / FRAMES_PER_SECOND) - (1000 / 60) * 0.5;\n// same\nconst INTERVAL = 1000 / FRAMES_PER_SECOND;\nconst MAX_FRAME_TIME = 1000 / FRAMES_PER_SECOND;\nconst MIN_FRAME_TIME = 20;\n// 16.666666666666667 * 2 - 16.666666666666667 * 0.5 = 25\n// const _drawInterval = parseInt(1000 / FRAMES_PER_SECOND);\nlet lastDrawTime = 0;\nlet lastFrameTime = 0;\n\n// 객체 grid 관련\nconst SIZE = {\n    MIN_WIDTH: 370,\n    MIN_HEIGHT: 208\n}\n\nconst GUIDE = {\n    POINT_SIZE: 40,\n    LINE_WIDTH: 4,\n    LINE_COLOR: \"rgba(0,184,152,1)\", // \"#F81894\"; hotpink\n    Z_INDEX_BUTTON_WIDTH: 80,\n    Z_INDEX_BUTTON_HEIGHT: 60,\n    Z_INDEX_BUTTON_COLOR: \"rgba(0,184,152,.75)\",\n    Z_INDEX_BUTTON_COLOR_UP: \"rgba(0,184,152,.85)\",\n    Z_INDEX_BUTTON_COLOR_DOWN: \"rgba(0,184,152,.5)\",\n    Z_INDEX_TEXT_FONT: \"48px Arial\",\n    Z_INDEX_TEXT_FONT_SIZE: 48,\n    Z_INDEX_TEXT_WIDTH: 80,\n    Z_INDEX_TEXT_HEIGHT: 80,\n    ARROW_WIDTH: 28,\n    ARROW_HEIGHT: 28,\n    ARROW_COLOR: \"#222222\"\n}\n\n// 마우스 버튼 custom constraint\n// (event.button의 상태가 non-click, click이 둘다 0이기 떄문에 non-click = -1, click = 0으로 지정)\nconst MOUSE_BUTTON = {\n    NONE: -1,\n    CLICKED: 0\n}\n\nconst SETTINGS = {\n    Z_INDEX_MIN: 1,\n    Z_INDEX_MAX: 9\n}\nexport default class VideoMixer {\n    constructor(canvasElementID, previewVideoElementID) {\n        this.videoObjectList = [];\n        this.videoObjectListAsc = [];\n\n        this.mouseButtonState = MOUSE_BUTTON.NONE;\n\n        this.initCanvas(canvasElementID);\n\n        // vertical , horizontal 캔버스가 화면에 1:1로 보여주는게 아니기 떄문에 마우스 좌표에 ratio값을 곱해줘야함\n        this.vRatio = SCREEN.width / this.uiCanvas.offsetWidth;\n        this.hRatio = SCREEN.height / this.uiCanvas.offsetHeight;\n\n\n        this.delta = 0;\n        this.now = 0;\n        this.then = Date.now();\n        this.bindEventHandler();\n    }\n\n    initCanvas(canvasElementID) {\n        // init uiCanvas\n        this.uiCanvas = document.querySelector(`#${canvasElementID}`);\n        this.uiCanvasCtx = this.uiCanvas.getContext(\"2d\", { desynchronized: true, alpha: false });\n        this.uiCanvas.width = SCREEN.width;\n        this.uiCanvas.height = SCREEN.height;\n\n        // init frontCanvas\n        this.frontCanvas = document.createElement('canvas');\n        this.frontCanvas.width = SCREEN.width;\n        this.frontCanvas.height = SCREEN.height;\n        this.frontCanvasCtx = this.frontCanvas.getContext(\"2d\", { desynchronized: true, alpha: false });\n\n        // issue: captureStream parameter로 프레임을 지정시 오히려 캡쳐가 끊기는 현상이 있음\n        // 일단은 parameter를 비우고 진행 (2019.11.4 기만)\n        this.mixedStream = this.frontCanvas.captureStream(0);\n    }\n\n\n    // attachMainWorker(workerInstance) {\n    //     this._mainWorker = workerInstance;\n    //     this._mainWorker.postMessage({\n    //         type: WORKER_MESSAGE_TYPE.ATTACH_CANVAS,\n    //         maincanvas: this.transferControl\n    //     }, [this.transferControl])\n\n    //     // this._mainWorker.onmessage = function(e) {\n    //     //     switch(e.data.type) {\n    //     //         case WORKER_MESSAGE_TYPE.PUT_OFFSCREEN:\n    //     //             const offscreenCtx = e.data.offscreen.getContext(\"2d\");\n        \n    //     //             const imageData = offscreenCtx.getImageData(0,0,offscreenCtx.width, offscreenCtx.height);\n        \n    //     //             this.canvasCtx.putImageData(imageData, 0, 0)\n    //     //             break;\n    //     //     }\n    //     // }\n    // }\n\n    enableCanvas(id, value) {\n        const idx = this.videoObjectList.findIndex(d => d.id === id);\n        const vObj = this.videoObjectList[idx];\n        vObj.setEnable(value)\n    }\n\n    getVideoObject(id) {\n        const idx = this.videoObjectList.findIndex(d => d.id === id);\n        const vObj = this.videoObjectList[idx];\n        return vObj;\n    }\n\n    addVideoObject(vObj) {\n        this.videoObjectList.push(vObj);\n        this.sortVideoObjectList();\n        // console.log(videoObject)\n        // clearTimeout(this._drawTimeoutHandler);\n        \n        // this.drawWithWorker(this.videoObjectList);\n\n        // const workerObject = {\n            // id: videoObject.id,\n            // top: videoObject.top,\n            // left: videoObject.left,\n            // width: videoObject.width,\n            // height: videoObject.height,\n            // zIndex: videoObject.zIndex,\n            // fillMode: videoObject.fillMode,\n            // transparent: videoObject.transparent,\n            // offscreen: videoObject.getOffscreenCanvas()\n        // }\n        // console.log(workerObject)\n        // this._mainWorker.postMessage({\n        //     TYPE: WORKER_MESSAGE_TYPE.ADD_OBJECT,\n        //     object: workerObject,\n        // });\n    }\n\n    removeVideoObject(id) {\n        const idx = this.videoObjectList.findIndex( val => val.id === id );\n        this.videoObjectList.splice(idx, 1);\n        const ascIdx = this.videoObjectListAsc.findIndex( val => val.id === id);\n        this.videoObjectListAsc.splice(ascIdx, 1);\n        this.detachEventObject();\n    }\n\n    draw(time) {\n        if(time - lastDrawTime < MAX_FRAME_TIME) {\n            // this.draw(performance.now());\n            window.requestAnimationFrame(this.draw.bind(this));\n            return;\n        }\n        lastDrawTime = time;\n\n        // clear & fill black background\n        // perfomance test clearRect() vs fillRect()\n        // https://stackoverflow.com/a/30830253\n        // (test-code : https://jsperf.com/canvas-fill-vs-clear)\n        this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n        this.bufferCanvasCtx.fillStyle = \"black\";\n        this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n        // draw video objects (order zIndex)\n        this.videoObjectList.map( vObj => {\n            const drawSource = vObj.getDrawSource();\n            if (!drawSource) return;\n            const { src } = drawSource;\n \n            // drawImage의 방법 세가지중 이방법은 최적화의 좋지 않아 구조 변경함.\n            // drawImage의 첫번째 메소드(3파라미터)를 쓰는게 최적화 방법에 제일 좋다고함 (2019-12-12 기만)\n            // this.canvasCtx.drawImage(\n            //     src,\n            //     0,\n            //     0,\n            //     srcWidth,\n            //     srcHeight,\n            //     vObj.drawLeft,\n            //     vObj.drawTop,\n            //     vObj.drawWidth,\n            //     vObj.drawHeight\n            // )\n            this.bufferCanvasCtx.drawImage(\n                src,\n                vObj.left,\n                vObj.top\n            )\n        })\n\n        // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n        if (typeof (OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n\n        // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n        this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n        if (this.mouseOverObject) {\n            if (!this.mouseOverObject.isFullscreen()) {\n                this.drawOutline();\n                this.drawTriangle();\n            }\n            this.drawZIndexButton();\n        }\n        // this.mixedStream.getVideoTracks()[0].requestFrame();\n     \n        // this.draw(performance.now())\n        // setTimeout(this.draw.bind(this), 10, performance.now())\n        window.requestAnimationFrame(this.draw.bind(this));\n    }\n\n    drawCalcDeltaTime() {\n        window.requestAnimationFrame(this.drawCalcDeltaTime.bind(this))\n        this.now = Date.now();\n        this.delta = this.now - this.then;\n\n        if(this.delta > INTERVAL) {\n            this.then = this.now - (this.delta % INTERVAL);\n\n            // clear & fill black background\n            // perfomance test clearRect() vs fillRect()\n            // https://stackoverflow.com/a/30830253\n            // (test-code : https://jsperf.com/canvas-fill-vs-clear)\n            this.frontCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n            this.frontCanvasCtx.fillStyle = \"black\";\n            this.frontCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n    \n            // draw video objects (order zIndex)\n            this.videoObjectList.forEach( vObj => {\n                const drawSource = vObj.getDrawSource();\n                if (!drawSource) return;\n                const { src, videoWidth, videoHeight } = drawSource;\n    \n                this.frontCanvasCtx.drawImage(\n                    src, 0, 0, videoWidth, videoHeight,\n                    vObj.left, vObj.top, vObj.width, vObj.height\n                )\n            })\n    \n            // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n            this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n            if (this.mouseOverObject) {\n                if (!this.mouseOverObject.isFullscreen()) {\n                    this.drawOutline();\n                    this.drawTriangle();\n                }\n                this.drawZIndexButton();\n            }\n\n\n            this.mixedStream.getVideoTracks()[0].requestFrame();\n        }\n        // this.mixedStream.getVideoTracks()[0].requestFrame();\n     \n        // this.draw(performance.now())\n        // setTimeout(this.draw.bind(this), 10, performance.now())\n    }\n\n    drawWithFps() {\n        this.startTime = Date.now();\n\n        // clear & fill black background\n        this.frontCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n        this.frontCanvasCtx.fillStyle = \"black\";\n        this.frontCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n        // draw video objects (order zIndex)\n        this.videoObjectList.map( vObj => {\n            const drawSource = vObj.getDrawSource();\n            if (!drawSource) return;\n            const { src, videoWidth, videoHeight } = drawSource;\n\n            this.frontCanvasCtx.drawImage(\n                src, 0, 0, videoWidth, videoHeight,\n                vObj.left, vObj.top, vObj.width, vObj.height\n            )\n        })\n\n        // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n        this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n        if (this.mouseOverObject) {\n            if (!this.mouseOverObject.isFullscreen()) {\n                this.drawOutline();\n                this.drawTriangle();\n            }\n            this.drawZIndexButton();\n        }\n\n        this.mixedStream.getVideoTracks()[0].requestFrame();\n        \n        this.executeTime = Date.now() - this.startTime;\n        this.nextFrameDelay = MAX_FRAME_TIME - this.executeTime;\n        if(this.nextFrameDelay <= MIN_FRAME_TIME) {\n            this.nextFrameDelay = MIN_FRAME_TIME;\n            Debugger.DroppedFrames.increase();\n        }\n        Debugger.Frames.setLastExecuteTime(this.executeTime);\n        Debugger.Frames.setLastFrameDelay(this.nextFrameDelay);\n        \n\n        // console.log(this.nextFrameDelay)\n        // console.log(\"예상:\", performance.now() + this.nextFrameDelay)\n        setTimeout(\n            this.drawWithFps.bind(this),\n            this.nextFrameDelay\n        )\n        // window.requestAnimationFrame(this.drawWithFps.bind(this))\n    }\n\n    drawWithoutFps(time) {\n        // clear & fill black background\n        this.bufferCanvasCtx.clearRect(0, 0, SCREEN.width, SCREEN.height);\n        this.bufferCanvasCtx.fillStyle = \"black\";\n        this.bufferCanvasCtx.fillRect(0, 0, SCREEN.width, SCREEN.height);\n\n        // draw video objects (order zIndex)\n        this.videoObjectList.map( vObj => {\n            const drawSource = vObj.getDrawSource();\n            if (!drawSource) return;\n            const { src } = drawSource;\n\n            this.bufferCanvasCtx.drawImage(\n                src,\n                vObj.left,\n                vObj.top\n            )\n        })\n\n        // 합성이 완료된 bufferCanvas의 이미지를 front로 draw\n        if (typeof (OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.bufferCanvas, 0, 0);\n\n        // 실질적으로 사용자에게 보여주는 ui 캔버스는 따로 그림\n        this.uiCanvasCtx.drawImage(this.frontCanvas, 0, 0);\n        if (this.mouseOverObject) {\n            if (!this.mouseOverObject.isFullscreen()) {\n                this.drawOutline();\n                this.drawTriangle();\n            }\n            this.drawZIndexButton();\n        }\n\n        setTimeout(this.drawWithoutFps.bind(this), 20)\n    }\n\n    drawOutline() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n        ctx.strokeStyle = GUIDE.LINE_COLOR;\n        ctx.lineWidth = GUIDE.LINE_WIDTH;\n        ctx.strokeRect(\n            destObject.left + parseInt(GUIDE.LINE_WIDTH / 2),\n            destObject.top + parseInt(GUIDE.LINE_WIDTH / 2),\n            destObject.width - parseInt(GUIDE.LINE_WIDTH + 1),\n            destObject.height - parseInt(GUIDE.LINE_WIDTH + 1)\n        );\n    }\n\n    drawTriangle() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n\n        const drawTopLeft = () => {\n            ctx.beginPath();\n            // x = right, y = bottom - POINT_SIZE\n            let x = destObject.left;\n            let y = destObject.top;\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = destObject.left + GUIDE.POINT_SIZE;\n            y = destObject.top;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = destObject.left;\n            y = destObject.top + GUIDE.POINT_SIZE;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.LINE_COLOR;\n            ctx.fill();            \n        }\n        const drawBottomRight = () => {\n            ctx.beginPath();\n            // x = right, y = bottom - POINT_SIZE\n            let x = destObject.left + destObject.width;\n            let y = destObject.top + destObject.height - GUIDE.POINT_SIZE;\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = destObject.left + destObject.width;\n            y = destObject.top + destObject.height;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = destObject.left + destObject.width - GUIDE.POINT_SIZE;\n            y = destObject.top + destObject.height;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n    \n            ctx.fillStyle = GUIDE.LINE_COLOR;\n            ctx.fill();\n        }\n        drawTopLeft();\n        drawBottomRight();\n    }\n\n    drawZIndexButton() {\n        const destObject = this.mouseOverObject;\n        const ctx = this.uiCanvasCtx;\n        let objTop = destObject.top + GUIDE.LINE_WIDTH;\n        let objRight = destObject.left + destObject.width - GUIDE.LINE_WIDTH;\n        if(destObject.isFullscreen()) {\n            objRight = SCREEN.width;\n        }\n        const drawButtonBackground = () => {\n            const drawUpButton = (color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(\n                    objRight - GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    objTop,\n                    GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                );\n            }\n\n            const drawDownButton = (color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(\n                    objRight - GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                    GUIDE.Z_INDEX_BUTTON_WIDTH,\n                    GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                );\n            }\n            \n            switch(this.clickPosition) {\n                case \"up-arrow\":\n                    if(this.mouseButtonState === MOUSE_BUTTON.NONE)\n                        drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR_UP);\n                    else if (this.mouseButtonState === MOUSE_BUTTON.CLICKED)\n                        drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR_DOWN);\n                    drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n                case \"down-arrow\":\n                    if (this.mouseButtonState === MOUSE_BUTTON.NONE)\n                        drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR_UP);\n                    else if (this.mouseButtonState === MOUSE_BUTTON.CLICKED)\n                        drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR_DOWN);\n                    drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n                default:\n                    drawUpButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    drawDownButton(GUIDE.Z_INDEX_BUTTON_COLOR);\n                    break;\n            }\n\n        }\n\n        const drawUpArrow = () => {\n            ctx.beginPath();\n            // x = button-center, y = arrowStart\n            let x = objRight - (GUIDE.Z_INDEX_BUTTON_WIDTH / 2);\n            let y = objTop + ((GUIDE.Z_INDEX_BUTTON_HEIGHT - GUIDE.ARROW_HEIGHT) / 2);\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = x + (GUIDE.ARROW_WIDTH / 2);\n            y = y + GUIDE.ARROW_HEIGHT;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = x - GUIDE.ARROW_WIDTH;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fill();\n        }\n\n        const drawDownArrow = () => {\n            ctx.beginPath();\n            // x = button-center, y = arrowStart\n            let x = objRight - (GUIDE.Z_INDEX_BUTTON_WIDTH / 2);\n            let y = objTop +\n                GUIDE.Z_INDEX_BUTTON_HEIGHT +\n                // GUIDE.Z_INDEX_TEXT_HEIGHT +\n                (GUIDE.Z_INDEX_BUTTON_HEIGHT / 2 + GUIDE.ARROW_HEIGHT / 2);\n            ctx.moveTo(x, y);\n            // x = right, y = bottom;\n            x = x + (GUIDE.ARROW_WIDTH / 2);\n            y = y - GUIDE.ARROW_HEIGHT;\n            ctx.lineTo(x, y);\n            // x = right - POINT_SIZE, y = bottom\n            x = x - GUIDE.ARROW_WIDTH;\n            ctx.lineTo(x, y);\n            ctx.closePath();\n\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fill();\n        }\n\n        const drawZIndexText = () => {\n            // background\n            ctx.fillStyle = GUIDE.Z_INDEX_BUTTON_COLOR;\n            ctx.fillRect(\n                objRight - GUIDE.Z_INDEX_TEXT_WIDTH,\n                objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT,\n                GUIDE.Z_INDEX_TEXT_WIDTH,\n                GUIDE.Z_INDEX_TEXT_HEIGHT,\n            );\n            // text\n            ctx.font = GUIDE.Z_INDEX_TEXT_FONT;\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = GUIDE.ARROW_COLOR;\n            ctx.fillText(\n                destObject.zIndex,\n                objRight - (GUIDE.Z_INDEX_TEXT_WIDTH / 2),\n                objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT + (GUIDE.Z_INDEX_TEXT_HEIGHT / 2)\n            )\n        }\n\n        drawButtonBackground();\n        drawUpArrow();\n        drawDownArrow();\n        // drawZIndexText();\n    }\n\n    // captureStream을 Manual하게 제어하는 함수.\n    // mixedStream의 captureStream(0) 으로 세팅해놔야 requestFrame()이 동작함.\n    captureFrame(time) {\n        if (time - lastFrameTime < FRAME_MIN_TIME) { //skip the frame if the call is too early\n            window.requestAnimationFrame(this.captureFrame.bind(this));\n            return; // return as there is nothing to do\n        }\n        lastFrameTime = time; // remember the time of the rendered frame\n        // OffscreenCanvas가 있으면 frontCanvas로 전체 이미지를 copy하는 과정이 필요\n        // 현재 Chrome에만 OffscreenCanvas가 지원되기 떄문에 검증작업 필요(2019-11-20 기만)\n        if(typeof(OffscreenCanvas))\n            this.frontCanvasCtx.drawImage(this.canvas, 0, 0);\n        this.mixedStream.getVideoTracks()[0].requestFrame();\n        window.requestAnimationFrame(this.captureFrame.bind(this))\n    }\n\n    // drawWithWorker(vObjList) {\n    //     vObjList.map(vObj => {\n    //         // console.log(vObj)\n    //         const sT = performance.now();\n    //         const imageData = vObj.getImageData();\n    //         const eT = performance.now();\n    //         // console.log(eT - sT)\n    //         if (!imageData) return;\n    //         this._mainWorker.postMessage({\n    //             type: WORKER_MESSAGE_TYPE.DRAW_IMAGE,\n    //             imageData: imageData,\n    //             left: vObj.left,\n    //             top: vObj.top,\n    //             width: vObj.width,\n    //             height: vObj.height,\n    //             fillMode: vObj.fillMode,\n    //             transparent: vObj.transparent,\n    //         })\n    //     })\n\n    //     this._mainWorker.postMessage({ type: WORKER_MESSAGE_TYPE.DRAW_MAIN_CANVAS })\n    //     // console.log(eT-sT)\n    //     this._drawTimeoutHandler = setTimeout(this.draw.bind(this), _intervalDraw, vObjList)\n    // }\n\n    // addAudioTrack(track) {\n    //     this.mixedStream.addTrack(track)\n    // }\n\n    getVideoTracks() {\n        return this.mixedStream.getVideoTracks();\n    }\n\n    // getMixedStream() { \n    //     return this.mixedStream;\n    // }\n\n    // getTracks() {\n    //     return this.mixedStream.getTracks();\n    // }\n\n    sortVideoObjectList() {\n        this.videoObjectList.sort(function (a, b) {\n            if (a.zIndex < b.zIndex) {\n                return -1;\n            } else if (a.zIndex > b.zIndex) {\n                return 1;\n            } else {\n                if(a.createdAt < b.createdAt) {\n                    return -1;\n                } else if(a.createdAt > b.createdAt) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        })\n        this.videoObjectListAsc = [];\n        for (let i = this.videoObjectList.length - 1; i >= 0; i--) {\n            this.videoObjectListAsc.push(this.videoObjectList[i])\n        }\n        // console.log(this.videoObjectList)\n        // console.log(this.videoObjectListAsc)\n    }\n\n    // getThumbnail(mime = 'image/png', quality=100) {\n    //     return new Promise((resolve, reject) => {\n    //         if(this.canvas === null) {\n    //             return reject(new Error('canvas not exists'));\n    //         }\n    //         this.canvas.toBlob(blob => resolve(blob), mime, quality);\n    //     });\n    // }\n\n    // capture(mime, quality) {\n    //     return this.getThumbnail(mime, quality);\n    // }\n\n    bindEventHandler() {\n        this.uiCanvas.ondblclick = (e) => {\n            const {clickObj, clickPosition} = this.findClickObject(e);\n            if (!clickObj) return;\n            if (clickPosition !== \"move\") return;\n            if (clickObj.isFullscreen()) {\n                // 되돌아갈 position값이 없을경우(처음부터 전체화면으로 삽입)\n                // 그럴경우 좌측 상단으로 보여줌\n                if (!clickObj.hasSavedPosition()) {\n                    clickObj.savePosition();\n                    let width = SIZE.MIN_WIDTH;\n                    let height = SIZE.MIN_HEIGHT;\n                    if(clickObj.width > clickObj.height) {\n                        const ratio = clickObj.height / clickObj.width;\n                        width = SIZE.MIN_WIDTH;\n                        height = width * ratio\n                    } else {\n                        const ratio = clickObj.width / clickObj.height;\n                        height = SIZE.MIN_HEIGHT;\n                        width = height * ratio;\n                    }\n                    clickObj.setPosition({\n                        top: 10,\n                        left: 10,\n                        width,\n                        height,\n                        zIndex: clickObj.zIndex,\n                        fullScreen: false\n                    });\n                } else {\n                    clickObj.restorePosition()\n                }\n                this.mouseOverObject = clickObj;\n            } else {\n                clickObj.savePosition();\n                let aspectRatio = clickObj.width / clickObj.height;\n                if(aspectRatio > 0) { // width > height\n                    const calcWidth = SCREEN.width;\n                    const calcHeight = SCREEN.width / aspectRatio;\n                    if(calcHeight > SCREEN.height) {\n                        clickObj.setPosition({\n                            top: 0,\n                            left: 0,\n                            width: SCREEN.height * aspectRatio,\n                            height: SCREEN.height,\n                            fullScreen: true\n                        });    \n                    } else {\n                        clickObj.setPosition({\n                            top: 0,\n                            left: 0,\n                            width: calcWidth,\n                            height: calcHeight,\n                            fullScreen: true\n                        });    \n                    }\n                } else {\n                    const calcHeight = SCREEN.height;\n                    const calcWidth = SCREEN.height * aspectRatio;\n                    clickObj.setPosition({\n                        top: 0,\n                        left: 0,\n                        width: calcWidth,\n                        height: calcHeight,\n                        fullScreen: true\n                    });\n                }\n\n                this.mouseOverObject = null;\n            }\n            this.sortVideoObjectList();\n        }\n\n        this.uiCanvas.onmousedown = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            this.mouseButtonState = e.button;\n            if(clickObj) {\n                if(clickObj.isFullscreen()) return;\n\n                this.clickObject = clickObj;\n                this.clickPosition = clickPosition;\n                this.startPos = {\n                    x: e.offsetX,\n                    y: e.offsetY\n                }\n                this.startObjectPos = {\n                    top: clickObj.top,\n                    left: clickObj.left,\n                    bottom: SCREEN.height - (clickObj.top + clickObj.height),\n                    right: SCREEN.width - (clickObj.left + clickObj.width),\n                    width: clickObj.width,\n                    height: clickObj.height,\n                    ratio: clickObj.height / clickObj.width\n                }\n            } else {\n                this.detachEventObject();\n            }\n        }\n        this.uiCanvas.onmouseover = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            this.mouseOverObject = clickObj;\n            this.clickPosition = clickPosition;\n        }\n        this.uiCanvas.onmouseout = (e) => {\n            this.detachEventObject();\n        }\n        this.uiCanvas.onmousemove = (e) => {\n            switch(this.mouseButtonState) {\n                case MOUSE_BUTTON.NONE:\n                    if(this.mouseOverObject) {\n                        this.detectMouseOut(e)\n                    }\n                    const { clickObj, clickPosition } = this.findClickObject(e);\n                    // fullscreen 모드가 아닌 오브젝트를 계속 scan\n                    if (clickObj) {\n                        this.mouseOverObject = clickObj;\n                        this.clickPosition = clickPosition;\n                        // 마우스 위치에 따라 커서 변경\n                        switch (clickPosition) {\n                            case \"up-arrow\":\n                            case \"down-arrow\":\n                                this.uiCanvas.style.cursor = \"pointer\";\n                                break;\n                            case \"move\":\n                                if(!clickObj.isFullscreen())\n                                    this.uiCanvas.style.cursor = \"move\";\n                                break;\n                            case \"top-left\":\n                            case \"bottom-right\":\n                                if (!clickObj.isFullscreen())\n                                    this.uiCanvas.style.cursor = \"nwse-resize\"; // top-left to bottom-right scale cursor\n                                break;\n                        }\n                    }\n                    break;\n                case MOUSE_BUTTON.CLICKED:\n                    if (this.clickObject) {\n                        // 커서 이동한 거리\n                        const moveX = e.offsetX - this.startPos.x;\n                        const moveY = e.offsetY - this.startPos.y;\n                        let moveX_inCanvas = this.calcUItoCanvasX(moveX);\n                        let moveY_inCanvas = this.calcUItoCanvasY(moveY)\n                        let resizeWidth = this.startObjectPos.width;\n                        let resizeHeight = resizeWidth * this.startObjectPos.ratio;\n                        switch (this.clickPosition) {\n                        case \"top-left\":\n                            moveX_inCanvas = -1 * moveX_inCanvas;\n                            resizeWidth = this.startObjectPos.width + moveX_inCanvas;\n                            resizeHeight = resizeWidth * this.startObjectPos.ratio;\n\n                            if (resizeWidth < SIZE.MIN_WIDTH) return;\n                            if (resizeHeight < SIZE.MIN_HEIGHT) return;\n\n                            // scale\n                            this.clickObject.setPosition({\n                                bottom: this.startObjectPos.bottom,\n                                right: this.startObjectPos.right,\n                                width: resizeWidth,\n                                height: resizeHeight\n                            });\n                            break;\n                        case \"bottom-right\":\n                            resizeWidth = this.startObjectPos.width + moveX_inCanvas;\n                            resizeHeight = resizeWidth * this.startObjectPos.ratio;\n\n                            if (resizeWidth < SIZE.MIN_WIDTH) return;\n                            if (resizeHeight < SIZE.MIN_HEIGHT) return;\n                            \n                            // scale\n                            this.clickObject.setPosition({\n                                top: this.startObjectPos.top,\n                                left: this.startObjectPos.left,\n                                width: resizeWidth,\n                                height: resizeHeight\n                            });\n                            break;\n                        case \"move\":\n                            if(this.clickObject.isFullscreen()) return;\n                            // console.log(e.offsetX )\n                            // console.log(this.startObjectPos.top, this.startObjectPos.left)\n                            // console.log(offsetX, offsetY)\n                            this.clickObject.left = this.startObjectPos.left + moveX_inCanvas;\n                            this.clickObject.top = this.startObjectPos.top + moveY_inCanvas\n                            break;\n                    }\n                }\n            }\n\n            // console.log(e.clientX, e.clientY, e.which);\n        }\n\n        this.uiCanvas.onmouseup = (e) => {\n            this.mouseButtonState = MOUSE_BUTTON.NONE\n        }\n\n        this.uiCanvas.onclick = (e) => {\n            const { clickObj, clickPosition } = this.findClickObject(e);\n            if(clickPosition === \"up-arrow\") {\n                if(clickObj.zIndex < SETTINGS.Z_INDEX_MAX) {\n                    clickObj.zIndex = clickObj.zIndex + 1;\n                    this.sortVideoObjectList();\n                }\n            } else if(clickPosition === \"down-arrow\") {\n                if(clickObj.zIndex > SETTINGS.Z_INDEX_MIN) {\n                    clickObj.zIndex = clickObj.zIndex - 1;\n                    this.sortVideoObjectList();\n                }\n            }\n        }\n    }\n\n    calcUItoCanvasX(x) {\n        return parseInt(x * this.vRatio);\n    }\n\n    calcUItoCanvasY(y) {\n        return parseInt(y * this.hRatio);\n    }\n\n\n    // 마우스포인터가 가르치는 오브젝트 검색\n    findClickObject(e) {\n        // draw는 zIndex가 낮은순으로 하지만,\n        // object detection은 zIndex가 높은순부터 해야 제일 위의 레이어가 선택됨\n        let objList = this.videoObjectListAsc;\n        const mouseX = this.calcUItoCanvasX(e.offsetX);\n        const mouseY = this.calcUItoCanvasY(e.offsetY);\n\n        let clickPosition = \"move\";\n        const findObj = objList.find( vObj => {\n            let objTop = vObj.top;\n            let objLeft = vObj.left;\n            let objBottom = vObj.top + vObj.height;\n            let objRight = vObj.left + vObj.width;\n            if(vObj.isFullscreen()) {\n                objTop = 0;\n                objLeft = 0;\n                objBottom = SCREEN.height;\n                objRight = SCREEN.width;\n            }\n\n\n            // 상단 클릭(높이 조절)\n            // if (mouseY >= (objTop - 2) && mouseY <= (objTop + 2) &&\n            //     mouseX >= (objLeft + 2) && mouseX <= (objRight - 2)) {\n            //     state = \"top\";\n            //     return vObj\n            // }\n\n            // top - left\n            if (mouseY >= objTop && mouseY <= (objTop + GUIDE.POINT_SIZE) &&\n                mouseX >= objLeft && mouseX <= (objLeft + GUIDE.POINT_SIZE)) {\n                clickPosition = \"top-left\";\n                return vObj;\n            }\n\n            // bottom - right\n            if (mouseY >= (objBottom - GUIDE.POINT_SIZE) && mouseY <= objBottom &&\n                mouseX >= (objRight - GUIDE.POINT_SIZE) && mouseX <= objRight) {\n                clickPosition = \"bottom-right\";\n                return vObj;\n            }\n\n            // 우측 상단 zIndex up\n            if (mouseY >= objTop && mouseY <= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT) &&\n                mouseX >= (objRight - GUIDE.Z_INDEX_BUTTON_WIDTH) && mouseX <= objRight) {\n                clickPosition = \"up-arrow\";\n                return vObj;\n            }\n\n            // 우측 상단 zIndex down\n            if (mouseY >= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT) &&\n                mouseY <= (objTop + GUIDE.Z_INDEX_BUTTON_HEIGHT * 2) &&\n                mouseX >= (objRight - GUIDE.Z_INDEX_BUTTON_WIDTH) && mouseX <= objRight) {\n                clickPosition = \"down-arrow\";\n                return vObj;\n            }\n\n            // 중앙 클릭()\n            if (mouseY >= objTop && mouseY <= objBottom &&\n                mouseX >= objLeft && mouseX <= objRight) {\n                clickPosition = \"move\";\n                return vObj;\n            }\n        })\n        return { clickObj: findObj, clickPosition }\n    }\n\n    detachEventObject() {\n        this.uiCanvas.style.cursor = null;\n        this.mouseOverObject = null;\n        this.clickObject = null;\n        this.clickPosition = null;\n        this.startPos = null;\n        this.startObjectPos = null;\n        this.mouseButtonState = MOUSE_BUTTON.NONE;\n    }\n\n    detectMouseOut(e) {\n        if(!this.mouseOverObject) return;\n        const mouseX = parseInt(e.offsetX * this.vRatio);\n        const mouseY = parseInt(e.offsetY * this.hRatio);\n        // 마우스 좌표와 범위체크\n        // console.log(mouseX, mouseY,\n        //     this.clickObject.left, this.clickObject.right, (this.clickObject.left + this.clickObject.width),\n        //     this.clickObject.top, this.clickObject.bottom, (this.clickObject.top + this.clickObject.height)\n        // )\n        if (mouseX < this.mouseOverObject.left ||\n            mouseX > this.mouseOverObject.right ||\n            mouseX > this.mouseOverObject.left + this.mouseOverObject.width ||\n            mouseY < this.mouseOverObject.top ||\n            mouseY > this.mouseOverObject.bottom ||\n            mouseY > this.mouseOverObject.top + this.mouseOverObject.height) {\n            this.uiCanvas.style.cursor = null;\n            this.mouseOverObject = null;\n        }\n    }\n\n    showObjectDrawTimes() {\n        return this.videoObjectList.map( videoObj => videoObj.lastDrawExecuteTime.toString() )\n    }\n\n}\n","// - 2020-02-13 기만\n// videoObject 내부의 offscreenCanvas에 video source를 지속적으로 draw를 하고,\n// videoMixer 에서 각 videoObject의 이미지(프레임)를 \n// 비동기적으로 draw를 하던방식에서,\n// videoObject는 더이상 draw 하지 않기로 변경\n// 이는 퍼포먼스 측면에서 차이가 없기떄문에 drawCall을 줄이려는 의도임. \n// 참고)\n// https://eggchicken.github.io/web-samples/draw_test.html\n// https://eggchicken.github.io/web-samples/draw_test2.html\n\n\nimport { SCREEN } from './preset/POSITIONS';\n\nexport const EVENT_MSG = {\n    REMOVE_ME: \"REMOVE_ME\"\n}\n\nexport default class VideoObject {\n    constructor(props) {\n        const {\n            id,\n            top, left, bottom, right,\n            width = 0, height = 0,\n            zIndex = 0,\n            fullScreen = false,\n\n            autoSize = false,\n            transparent = false,\n            onended = null,\n\n            enabled = true,\n\n            source,\n            sourceType = \"stream\",\n        } = props;\n\n        this._id = id;\n\n        this._transparent = transparent;\n        this._enabled = enabled;\n\n        this._source = source;\n        this._sourceType = sourceType;\n\n        this._top = top;\n        this._left = left;\n        this._bottom = bottom;\n        this._right = right;\n        this._width = width;\n        this._height = height;\n        this._zIndex = zIndex;\n        this._fullScreen = fullScreen;\n        this._createdAt = performance.now();\n\n        if (autoSize) {\n            const wScale = width / this._source.videoWidth;\n            // const ratio = this._source.videoWidth / this._source.videoHeight;\n            // console.log(this._source.videoHeight, wScale, this._source.videoHeight * wScale)\n            this._height = this._source.videoHeight * wScale;\n        }\n\n        \n        // if (typeof OffscreenCanvas !== \"undefined\") {\n        //     this._offscreenCanvas = new OffscreenCanvas(this._width, this._height);\n        // } else {\n        //     this._offscreenCanvas = document.createElement('canvas');\n        // }\n\n        // this._offscreenCanvasCtx = this._offscreenCanvas.getContext(\n        //     \"2d\",\n        //     {\n        //         desynchronized: true,\n        //         alpha: false\n        //     });\n\n        this.setPosition({\n            top: this._top,\n            left: this._left,\n            bottom: this._bottom,\n            right: this._right,\n            width: this._width,\n            height: this._height\n        })\n\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    setEnable(value) {\n        this._enabled = value;\n    }\n\n    get enabled() {\n        return this._enabled;\n    }\n\n    \n    getDrawSource() {\n        if(!this._enabled) return;       \n        // if(this._outline) this.drawOutline()\n\n        const videoWidth = Math.max(this._source.videoWidth || 0 , this._source.width || 0);\n        const videoHeight = Math.max(this._source.videoHeight || 0, this._source.height || 0)\n        if (videoWidth !== 0 && videoHeight !== 0) {\n            // return { src: this._offscreenCanvas, srcWidth, srcHeight }\n            return { src: this._source, videoWidth, videoHeight }\n        }\n    }\n\n    isFullscreen() {\n        return this._fullScreen;\n    }\n\n    hasSavedPosition() {\n        return this._savedPosition\n    }\n\n    savePosition() {\n        this._oldTop = this._top;\n        this._oldLeft = this._left;\n        this._oldBottom = this._bottom;\n        this._oldRight = this._right;\n        this._oldWidth = this._width;\n        this._oldHeight = this._height;\n        this._oldZIndex = this._zIndex;\n        this._oldFullScreen = this._fullScreen;\n        this._savedPosition = true;\n    }\n\n    restorePosition() {\n        this.setPosition({\n            top: this._oldTop,\n            left: this._oldLeft,\n            bottom: this._oldBottom,\n            right: this.oldRight,\n            width: this._oldWidth,\n            height: this._oldHeight,\n            zIndex: this._oldZIndex,\n            fullScreen: this._oldFullScreen\n        });\n    }\n\n    setPosition(values) {\n        const {\n            top,\n            left,\n            bottom,\n            right,\n            width = this._width,\n            height = this._height,\n            zIndex = this.zIndex,\n            fullScreen = this._fullScreen\n        } = values;\n        this._top = bottom ? undefined : top;\n        this._left = right ? undefined : left;\n        this._bottom = top ? undefined : bottom;\n        this._right = left ? undefined : right;\n        this._width = width;\n        this._height = height;\n        this._zIndex = zIndex;\n        this._fullScreen = fullScreen;\n\n        if (bottom && !top) {\n            this._top = SCREEN.height - bottom - height;\n            this._bottom = undefined;\n        }\n\n        if (right && !left) {\n            this._left = SCREEN.width - right - width;\n            this._right = undefined;\n        }\n        // console.log(\n        //     top,\n        //     left,\n        //     bottom,\n        //     right,\n        //     width,\n        //     height,\n        // )\n        // console.log(\n        //     this._top,\n        //     this._left,\n        //     this._bottom,\n        //     this._right ,\n        //     this._width ,\n        //     this._height ,\n        //     this._zIndex,\n        // )\n\n    }\n\n\n    // autoSize() {\n    //     this._width = this._source.videoWidth;\n    //     this._height = this._source.videoHeight;\n    //     this._offscreenCanvas.width = this._source.videoWidth;\n    //     this._offscreenCanvas.height = this._source.videoHeight;\n    //     setTimeout(this.autoSize.bind(this), 100)\n    // }\n\n\n    get top() {\n        return this._top;\n    }\n\n    set top(top) {\n        this._top = top;\n    }\n\n    get left() {\n        return this._left;\n    }\n\n    set left(left) {\n        this._left = left;\n    }\n\n\n    get width() {\n        return this._width;\n    }\n\n    set width(width) {\n        this._width = width;\n    }\n\n    get height() {\n        return this._height;\n    }\n\n    set height(height) {\n        this._height = height;\n    }\n\n    get zIndex() {\n        return this._zIndex;\n    }\n\n    set zIndex(zIndex) {\n        this._zIndex = zIndex;\n    }\n\n    set outLine(onOff) {\n        this._outline = onOff;\n    }\n\n    get createdAt() {\n        return this._createdAt\n    }\n\n    get lastDrawExecuteTime() {\n        return this._drawExecuteTime;\n    }\n}\n\n/** @description src의 형태를 파악하여 스트림으로 변환합니다.\n * @history getStream => convertVideoStream\n * @param {MediaStream|MediaStreamTrack} src MediaStream or MediaStreamTrack\n * @return {MediaStream} stream\n */\nexport const convertVideoStream = src => {\n    const stream = new MediaStream();\n// console.log(src instanceof MediaStream);\n// console.log(src instanceof MediaStreamTrack)\n    if (src instanceof MediaStream) {\n        src.getVideoTracks().forEach(track => stream.addTrack(track));\n    } else if (src instanceof MediaStreamTrack && src.kind === 'video') {\n        stream.addTrack(src);\n    } else {\n        throw new Error();\n    }\n\n    return stream;\n};\n","import Debugger from './StreamMixer.Debugger';\n\nimport AudioMixer from './AudioMixer/AudioMixer';\nimport AudioObject from './AudioMixer/AudioObject';\nimport VideoMixer from './VideoMixer/VideoMixer';\nimport VideoObject from './VideoMixer/VideoObject';\n\nimport { SCREEN, PRESET_POSITION } from './VideoMixer/preset/POSITIONS'\n// import ModuleToWorkerUrl from './Utils/ModuleToWorkerUrl';\n// import { WORKER_MESSAGE_TYPE } from './VideoMixer/VideoObjectWorker';\n\nexport default (() => {\n    let _videoElementList = [];\n    let _videoMixer = null;\n    let _audioMixer = null;\n    let _previewVideoID = null;\n    let _previewVideo = null;\n    let _outputStream = null;\n\n    const init = async (canvasElementID, videoElementID) => {\n        _previewVideoID = videoElementID;\n        _videoMixer = new VideoMixer(canvasElementID);\n        // _videoMixer.draw(performance.now());\n        // _videoMixer.drawWithoutFps(performance.now());\n        // _videoMixer.drawWithFps();\n        _videoMixer.drawCalcDeltaTime();\n        // _videoMixer.captureFrame();\n        _audioMixer = new AudioMixer();\n\n        await initStream();\n        // initPreviewVideo(_outputStream);\n        Debugger.init(_videoElementList, _videoMixer);\n    }\n\n    const initPreviewVideo = (stream) => {\n        _previewVideo = document.getElementById(_previewVideoID);\n        _previewVideo.srcObject = stream;\n        _previewVideo.play()\n    }\n\n    /** @description 미디어를 추가합니다. (Promise)\n     * @param {object} props {source, sourceType, video:{}, audio{}}\n     * source: 미디어 소스 (stream | url)\n     * string sourceType: 미디어 소스에 따라 타입 지정 (\"stream\" | \"url\")\n     * object video: 비디오 위치 및 크기 옵션\n     * object audio: 오디오 옵션\n     * @return {string} objID\n     */\n    const addMedia = (props = { source, sourceType: \"stream\", video: {}, audio: {}, onended}) => {\n        return new Promise( async (resolve, reject) => {\n            const { source, sourceType } = props;\n\n            const objID = generateID();\n\n            // 공통 비디오 객체 생성후\n            const videoEl = document.createElement('video');\n            if (sourceType === \"url\") {\n                videoEl.muted = false;\n                videoEl.autoplay = true;\n                videoEl.src = source;\n                videoEl.load();\n                if (props.video.startTime) {\n                    videoEl.currentTime = props.video.startTime;\n                }\n                // videoEl.play();\n                // videoEl.muted = true;\n                videoEl.crossOrigin = 'anonymous';\n            } else {\n                if(props.audio.mediaType === \"mycam\")\n                    videoEl.muted = true;\n                    \n                videoEl.srcObject = source;\n                if (props.video.startTime) {\n                    videoEl.currentTime = props.video.startTime;\n                }\n            }\n\n            // play 직후 cors오류가 떨어질 수 있기 때문에 promise 타입으로 체크\n            videoEl.play()\n            .then(() => {\n\n                if (sourceType === \"url\") videoEl.crossOrigin = 'anonymous';\n\n                if (props.onended) {\n                    videoEl.onended = () => {\n                        props.onended(objID);\n                    }\n                }\n\n                _videoElementList.push({\n                    id: objID,\n                    videoEl,\n                    stream: sourceType === 'stream' ? source : null\n                })\n\n                const vObj = new VideoObject({\n                    id: objID,\n                    stream: source,\n                    source: videoEl,\n                    sourceType,\n                    ...props.video\n                });\n                _videoMixer.addVideoObject(vObj);\n\n                if(sourceType === \"url\") {\n                    const aObj = new AudioObject({\n                        id: objID,\n                        source: videoEl,\n                        sourceType,\n                        context: _audioMixer.getContext(),\n                        destination: _audioMixer.getDestination(),\n                        ...props.audio,\n                    })\n                    _audioMixer.addAudioObject(aObj);\n                } else {\n                    if(source.getAudioTracks && source.getAudioTracks().length !== 0) {\n                        const aObj = new AudioObject({\n                            id: objID,\n                            source: source,\n                            sourceType,\n                            context: _audioMixer.getContext(),\n                            destination: _audioMixer.getDestination(),\n                            ...props.audio,\n                        })\n                        _audioMixer.addAudioObject(aObj);\n                    }\n                }\n\n                \n                resolve({ objID })\n            })\n            .catch((e) => {\n                console.log(e.toString());\n                reject({ err: \"not play video\" })\n            });\n        })\n    }\n\n    const findVideoItem = objID => {\n        const idx = _videoElementList.findIndex(k => k.id === objID);\n        return _videoElementList[idx];\n    }\n\n    const removeMedia = objID => {\n        const idx = _videoElementList.findIndex(k => k.id === objID);\n        // console.log(_videoElementList[idx].id);\n        // console.log(_videoElementList[idx].videoEl)\n        if (idx === -1 || !_videoElementList[idx]) {\n            console.log(`[StreamMixer] %cNot Found MediaObject : ${objID}`,'background: red; color: #fff')\n            return;\n        }\n\n        _videoMixer.removeVideoObject(objID);\n        _audioMixer.removeAudioObject(objID);\n\n        if (_videoElementList[idx].videoEl)\n            _videoElementList[idx].videoEl = undefined;\n        _videoElementList.splice(idx, 1);\n    }\n\n    const changeStream = (objID, stream) => {\n        return new Promise( (resolve, reject) => {\n            let item = findVideoItem(objID);\n            if(!item) reject(\"not found mediaObject\");\n            \n            item.videoEl.srcObject = stream;\n            item.videoEl.play();\n            return resolve();\n        })\n    }\n\n    const generateID = () => {\n        return '_' + Math.random().toString(36).substr(2, 9);\n    }\n\n    const initStream = async function() {\n        const mixedStream = new MediaStream();\n\n        _videoMixer.getVideoTracks().forEach(function(track) {\n            mixedStream.addTrack(track);\n        })\n        _audioMixer.getAudioTracks().forEach(function(track) {\n            mixedStream.addTrack(track);\n        })\n        _outputStream = mixedStream;\n        // const options = {\n        //     audioBitsPerSecond : 128000,\n        //     videoBitsPerSecond : 2500000,\n        //     mimeType : 'video/webm;codecs=h264'\n        //   }\n        // const mediaRecorder = new MediaRecorder(mixedStream, options);\n        // mediaRecorder.start();\n        // _outputStream = mediaRecorder.stream;\n        // _outputStream = await initPreviewVideo(mixedStream);\n\n    }\n\n    const getStream = function() {\n        // 비디오 믹서에 오디오 트랙 합친후 트랙으로 꺼내기\n        return _outputStream;\n    }\n\n\n    const getAudioTracks = function() {\n        return _audioMixer.getAudioTracks();\n    }\n\n    // const mute = function(value) {\n    //     _audioMixer.setMute(value);\n    // }\n    const enableCanvas = function(id, value) {\n        _videoMixer.enableCanvas(id, value)\n    }\n\n    const pause = function (objID) {\n        const videoItem = findVideoItem(objID);\n        videoItem.videoEl.pause();\n    }\n\n    const play = function(objID) {\n        const videoItem = findVideoItem(objID);\n        videoItem.videoEl.play();\n    }\n\n    const mute = function(id, value) {\n        _audioMixer.mute(id, value)\n    }\n\n    const getCurrentTime = function(id) {\n        const idx = _videoElementList.findIndex(k => k.id === id);\n        const item = _videoElementList[idx];\n        if(!item) return 0;\n        return item.videoEl.currentTime;\n    }\n\n    const setCurrentTime = function(id, time) {\n        const idx = _videoElementList.findIndex(k => k.id === id);\n        const item = _videoElementList[idx];\n        if (!item) return;\n        item.videoEl.currentTime = time;\n    }\n\n    const setPosition = function(values) {\n        const vObj = _videoMixer.getVideoObject(values.id);\n        if (!vObj) return;\n        vObj.setPosition(values)\n        _videoMixer.sortVideoObjectList();\n    }\n\n    const setDrawMode = function(val) {\n        _videoMixer.setDrawMode(val)\n    }\n\n    const setVolume = function(id, value) {\n        _audioMixer.setVolume(id, value)\n    }\n\n    return {\n        init,\n        addMedia,\n        removeMedia,\n        changeStream,\n        getStream,\n        getAudioTracks,\n        SCREEN,\n        PRESET_POSITION,\n\n        enableCanvas,\n        pause,\n        play,\n        mute,\n        setVolume,\n        getCurrentTime,\n        setCurrentTime,\n        setPosition,\n\n        setDrawMode,\n\n        // getPredictedEncodeTime,\n        // getPredictedEncodeTime,\n        \n        Debug: {...Debugger}\n    }\n    \n})()","import StreamMixer from './StreamMixer';\n// import * as UTILS from './ARTCUtils';\n// import { getVisualiser, getCreator } from './externals';\n\nfunction _prepareNamespaceAndModule(module) {\n    return typeof window.StreamMixer === 'object'\n        ? Object.assign({}, window.StreamMixer, module)\n        : module;\n}\n\nexport default StreamMixer"],"sourceRoot":""}